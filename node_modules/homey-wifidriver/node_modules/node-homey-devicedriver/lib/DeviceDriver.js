'use strict';

const _ = require('underscore');

const events = require('events');

const Device = require('./Device');

class DeviceDriver extends events.EventEmitter {

	constructor(driverId, options) {
		super();

		// Get driver specification as defined in app.json
		this.driver = _.findWhere(Homey.manifest.drivers, { id: driverId });

		// Override default options with provided options object
		this.options = Object.assign({
			debug: false,
			capabilities: {},
			initDevice: (device, callback) => callback(null, device),
		}, options);

		this.init = this.init.bind(this);
		this.added = this.added.bind(this);
		this.deleted = this.deleted.bind(this);

		if (typeof this.options.pair === 'function') this.pair = this.options.pair;

		this.devices = [];
		this.uninitializedDevices = [];
		this.capabilities = {};

		// Loop over all capabilities specified in app.json
		this.driver.capabilities.forEach(capabilityId => {
			if (typeof this.options.capabilities[capabilityId] === 'undefined') {
				throw new Error(`missing_options_capability: ${capabilityId}`);
			}

			// Create capability object
			this.capabilities[capabilityId] = {};

			// Define get function for capability
			this.capabilities[capabilityId].get = (deviceData, callback) => {
				const device = this.getDevice(deviceData);
				if (device instanceof Error) return callback(device);

				if (typeof this.options.capabilities[capabilityId].get === 'function') {
					this.options.capabilities[capabilityId].get(device, (err, result) => {
						this._log(`get ${capabilityId} -> ${err || result}`);
						return callback(err, result);
					});
				} else {
					this._log(`get ${capabilityId} -> ${device.state[capabilityId]}`);

					return callback(device.state[capabilityId]);
				}
			};

			// Define set function for capability
			this.capabilities[capabilityId].set = (deviceData, value, callback) => {
				const device = this.getDevice(deviceData);
				if (device instanceof Error) return callback(device);

				this._log('set', capabilityId, value);

				this.options.capabilities[capabilityId].set(device, value, (err, result) => {
					if (err) return callback(err);

					// Check if value has changed
					if (typeof device.state[capabilityId] !== 'undefined') {
						if (device.state[capabilityId] !== result) device.emit(capabilityId, result);

						// Update value in state object
						device.state[capabilityId] = result;

						// Emit realtime event
						this.realtime(deviceData, capabilityId, result);
					}

					return callback(err, result);
				});
			};
		});
	}

	/**
	 * Method that will be called on driver
	 * initialisation.
	 * @param devicesData
	 * @param callback
	 * @returns {*}
	 */
	init(devicesData, callback) {
		if (devicesData.length < 1) return callback(null, true);
		this._log(`init() -> initialize ${devicesData.length} devices`);
		const initializationPromises = [];

		// Loop over all installed devices
		devicesData.forEach((deviceData) => {

			// Initialize the devices
			initializationPromises.push(this.initDevice(deviceData));
		});

		Promise.all(initializationPromises)
			.then(() => callback(null, true))
			.catch(err => callback(err));
	}

	/**
	 * Method that will be called when a user
	 * adds a device.
	 * @param deviceData
	 * @param callback
	 * @returns {*}
	 */
	added(deviceData, callback) {
		this.initDevice(deviceData)
			.then(() => callback(null, true))
			.catch(err => callback(err));
	}

	/**
	 * Method that will be called when a user
	 * deletes a device.
	 * @param deviceData
	 * @param callback
	 */
	deleted(deviceData, callback) {
		this.deleteDevice(deviceData)
			.then(() => callback(null, true))
			.catch(err => callback(err));
	}

	/**
	 * Initializes a device.
	 * @param deviceData
	 * @param retry - true if retrying to prevent state change
	 */
	initDevice(deviceData, retry) {
		if (!deviceData) return Promise.reject(new Error('invalid_device_data'));
		this._log('initDevice() -> start device initialization');
		if (!retry) this.setUnavailable(deviceData, __('initializing'));
		return new Promise(resolve => {
			let device = new Device(deviceData, { capabilities: this.driver.capabilities });
			this.options.initDevice(device, (err, initializedDevice) => {
				if (err) {

					this._warn('initDevice() -> failed to initialize device');

					this.uninitializedDevices[JSON.stringify(deviceData)] =
						(typeof this.uninitializedDevices[JSON.stringify(deviceData)] === 'undefined') ? 0 : this.uninitializedDevices[JSON.stringify(deviceData)] + 1;

					if (!retry) this.setUnavailable(deviceData, __('not_found'));

					setTimeout(() => {
						this._log(`initDevice() -> retry device initialization (tries: ${this.uninitializedDevices[JSON.stringify(deviceData)]}`);
						this.initDevice(deviceData, true);
					}, this._getInitializationRetryInterval(this.uninitializedDevices[JSON.stringify(deviceData)]));

					return resolve();
				}

				// Reset initialization interval counter
				this.uninitializedDevices[JSON.stringify(deviceData)] = 0;

				this.devices.push(initializedDevice);
				this.setAvailable(deviceData);
				return resolve();
			});
		});
	}

	/**
	 * Device went offline, mark as
	 * unavailable and start search.
	 * @param device
	 */
	deviceWentOffline(device) {
		this._log('deviceWentOffline() -> mark as offline and start search');
		this.initDevice(device.data);
	}

	/**
	 * Method called when a user
	 * deletes a device from Homey.
	 * @param deviceData
	 */
	deleteDevice(deviceData) {
		if (!deviceData) {
			this._warn('deleteDevice() -> called without deviceData parameter');
			return Promise.reject(new Error('invalid_device_data'));
		}

		const device = this.getDevice(deviceData);

		if (device instanceof Error) {
			this._error('deleteDevice() -> called with invalid deviceData parameter');
			return Promise.reject(new Error('invalid_device'));
		}

		this._log('deleteDevice() -> device was deleted, clean up');

		return new Promise(resolve => {
			const prevLength = this.devices.length;
			this.devices = _.without(this.devices, this.getDevice(deviceData));
			this._log(`deleteDevice() -> removed device from list, prev size ${prevLength}, current size ${this.devices.length}`);
			return resolve();
		});
	}

	/**
	 * Returns device from internal devices list.
	 * @param deviceData
	 * @returns {*}
	 */
	getDevice(deviceData) {
		if (!deviceData) {
			this._warn('getDevice() -> called without deviceData parameter');
			return new Error('invalid_device_data');
		}

		return _.find(this.devices, device => _.isEqual(device.data, deviceData)) || new Error('invalid_device');
	}

	/**
	 * Calculate how on what interval to retry
	 * the device initialization.
	 * @param count
	 * @returns {number}
	 * @private
	 */
	_getInitializationRetryInterval(count) {
		count++;
		if (count <= 3) return 15000; // 15 seconds
		else if (count <= 7) return 60000; // 1 minute
		else if (count >= 8) return 15 * 60000; // 15 minutes
	}

	/**
	 * Log method, log level info.
	 */
	_log() {
		if (!this.options.debug) return;
		const args = Array.prototype.slice.call(arguments);
		args.unshift('[info]');
		args.unshift('\t');
		args.unshift(timestamp());
		console.log.apply(null, args);
	}

	/**
	 * Log method, log level warn.
	 */
	_warn() {
		if (!this.options.debug) return;
		const args = Array.prototype.slice.call(arguments);
		args.unshift('[warn]');
		args.unshift('\t');
		args.unshift(timestamp());
		console.log.apply(null, args);
	}

	/**
	 * Log method, log level error.
	 */
	_error() {
		if (!this.options.debug) return;
		const args = Array.prototype.slice.call(arguments);
		args.unshift('[error]');
		args.unshift('\t');
		args.unshift(timestamp());
		console.error.apply(null, args);
	}
}

/**
 * Create current timestamp,
 * HH:MM:SS:sss
 * @returns {string}
 */
function timestamp() {
	const d = new Date();
	return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}:${pad(d.getMilliseconds())}`;
}

/**
 * Pad a value with zero if necessary.
 * @param value
 * @returns {string}
 */
function pad(value) {
	return (value < 10) ? `0${value}` : value;
}

module.exports = DeviceDriver;
