'use strict';

const _ = require('underscore');

const events = require('events');

const Device = require('./Device');

class DeviceDriver extends events.EventEmitter {

	/**
	 * DeviceDriver constructor, takes a driverId
	 * and options object. Creates get and set functions
	 * for all capabilities the driver supports.
	 * @param driverId
	 * @param options
	 */
	constructor(driverId, options) {
		super();

		this.devices = [];
		this.uninitializedDevices = [];
		this.capabilities = {};
		this.driver = _.findWhere(Homey.manifest.drivers, { id: driverId });

		// Override default options with provided options object
		this.options = Object.assign({
			debug: false,
			capabilities: {},
			initDevice: (device, callback) => callback(null, device),
		}, options);

		this.init = this.init.bind(this);
		this.added = this.added.bind(this);
		this.deleted = this.deleted.bind(this);

		// Expose pair object on root scope
		if (typeof this.options.pair === 'function') this.pair = this.options.pair;

		// Loop over all capabilities specified in app.json
		this.driver.capabilities.forEach(capabilityId => {
			if (typeof this.options.capabilities[capabilityId] === 'undefined') {
				throw new Error(`missing_options_capability: ${capabilityId}`);
			}

			// Create capability object
			this.capabilities[capabilityId] = {};

			// Define get function for capability
			this.capabilities[capabilityId].get = (deviceData, callback) => {
				const device = this.getDevice(deviceData);
				if (device instanceof Error) return callback(device);

				if (typeof this.options.capabilities[capabilityId].get === 'function') {
					this.options.capabilities[capabilityId].get(device, (err, result) => {
						this._log(`get ${capabilityId} -> ${err || result}`);
						return callback(err, result);
					});
				} else {
					this._log(`get ${capabilityId} -> ${device.capabilities[capabilityId].get()}`);
					return callback(null, device.capabilities[capabilityId].get());
				}
			};

			// Define set function for capability
			this.capabilities[capabilityId].set = (deviceData, value, callback) => {
				const device = this.getDevice(deviceData);
				if (device instanceof Error) return callback(device);

				this._log('set', capabilityId, value);
				this.options.capabilities[capabilityId].set(device, value, (err, result) => {
					if (err) return callback(err);
					device.capabilities[capabilityId].set(result);
					return callback(err, result);
				});
			};
		});
	}

	/**
	 * Method that will be called on driver
	 * initialisation.
	 * @param devicesData
	 * @param callback
	 * @returns {*}
	 */
	init(devicesData, callback) {
		if (devicesData.length < 1) return callback(null, true);
		this._log(`init() -> initialize ${devicesData.length} devices`);
		const initializationPromises = [];

		// Loop over all installed devices and start device initialization
		devicesData.forEach((deviceData) => initializationPromises.push(this.initDevice(deviceData)));

		// Wait for all devices to have been initialized
		Promise.all(initializationPromises)
			.then(() => {
				this._log(`init() -> all ${initializationPromises.length} devices are initialized`);
				return callback(null, true);
			})
			.catch(err => {
				this._error(`init() -> one or more devices failed to initialize`, err);
				return callback(err);
			});
	}

	/**
	 * Method that will be called when a user
	 * adds a device.
	 * @param deviceData
	 * @param callback
	 * @returns {*}
	 */
	added(deviceData, callback) {
		this.initDevice(deviceData)
			.then(() => callback(null, true))
			.catch(err => callback(err));
	}

	/**
	 * Method that will be called when a user
	 * deletes a device.
	 * @param deviceData
	 * @param callback
	 */
	deleted(deviceData, callback) {
		this.deleteDevice(deviceData)
			.then(() => callback(null, true))
			.catch(err => callback(err));
	}

	/**
	 * Initializes a device.
	 * @param deviceData
	 * @param retry - true if retrying to prevent state change
	 */
	initDevice(deviceData, retry) {
		if (!deviceData) return Promise.reject(new Error('invalid_device_data'));
		this._log('initDevice() -> start device initialization');
		if (!retry) this.setUnavailable(deviceData, __('initializing'));
		return new Promise(resolve => {
			let device = (!retry) ? new Device(deviceData, { capabilities: this.driver.capabilities }) : this.getDevice(deviceData, this.uninitializedDevices);

			// Bind unavailable event
			device.on('unavailable', () => {
				this._log('deviceWentOffline() -> mark as offline and start search');
				this.initDevice(device.data);
			});

			// Bind capability changed events to emit realtime
			this.driver.capabilities.forEach(capability => {
				device.on(`${capability}_changed`, value => {
					this._log(`${capability}_changed -> ${value}`);
					this.realtime(device.data, capability, value)
				});
			});

			this.options.initDevice(device, (err, initializedDevice) => {
				if (err) {
					this._error('initDevice() -> failed to initialize device');
					if (!retry) this.setUnavailable(deviceData, __('not_found'));
					setTimeout(() => {
						this._log(`initDevice() -> retry device initialization (tries: ${device.initializationRetryCount}`);
						this.initDevice(deviceData, true);
					}, device.getInitializationRetryInterval());
					device.initializationRetryCount++;
					this.uninitializedDevices.push(device);
					return resolve();
				}

				// Setup polling intervals if specified in options
				if (this.options.pollingIntervalsOptions) {
					for (const key in this.options.pollingIntervalsOptions) {
						if (this.options.pollingIntervalsOptions.hasOwnProperty(key)) {
							if (typeof key === 'string') {
								if (this.capabilities[key] && typeof this.capabilities[key].get === 'function') {

									// Set capability pollers
									device.pollingIntervals[key] = setInterval(() => {
										this.capabilities[key].get(device.data, (err) => {
											if (err) this._error(`polling() -> ${key} -> failed`, err);
										});
									}, this.options.pollingIntervalsOptions[key]);
								} else {

									// Set custom pollers
									device.pollingIntervals[key] = setInterval(() => {
										if (typeof this.options.pollingInterval === 'function') this.options.pollingInterval(device);
									}, this.options.pollingIntervalsOptions[key]);
								}
							} else {
								this._warn('initDevice() -> invalid key provided in pollingIntervalsOptions object only strings allowed');
							}
						}
					}
				}
				if (retry) this.uninitializedDevices = _.without(this.uninitializedDevices, this.getDevice(deviceData, this.uninitializedDevices));
				this.devices.push(initializedDevice);
				this.setAvailable(deviceData);
				return resolve(initializedDevice);
			});
		});
	}

	/**
	 * Method called when a user
	 * deletes a device from Homey.
	 * @param deviceData
	 */
	deleteDevice(deviceData) {
		if (!deviceData) {
			this._error('deleteDevice() -> called without deviceData parameter');
			return Promise.reject(new Error('invalid_device_data'));
		}

		const device = this.getDevice(deviceData);
		if (device instanceof Error) {
			this._error('deleteDevice() -> called with invalid deviceData parameter');
			return Promise.reject(new Error('invalid_device'));
		}

		return new Promise(resolve => {
			const prevLength = this.devices.length;
			if (device) device.destroy();
			this.devices = _.without(this.devices, this.getDevice(deviceData));
			this._log(`deleteDevice() -> device destroyed and removed from list, prev size ${prevLength}, current size ${this.devices.length}`);
			return resolve(device);
		});
	}

	/**
	 * Returns device from internal devices list.
	 * @param deviceData
	 * @param list
	 * @returns {*}
	 */
	getDevice(deviceData, list) {
		if (!deviceData) {
			this._error('getDevice() -> called without deviceData parameter');
			return new Error('invalid_device_data');
		}
		return _.find(list || this.devices, device => _.isEqual(device.data, deviceData)) || new Error('invalid_device');
	}

	/**
	 * Log method, log level info.
	 */
	_log() {
		if (!this.options.debug) return;
		const args = Array.prototype.slice.call(arguments);
		args.unshift('[info]');
		args.unshift('\t');
		args.unshift(timestamp());
		console.log.apply(null, args);
	}

	/**
	 * Log method, log level warn.
	 */
	_warn() {
		if (!this.options.debug) return;
		const args = Array.prototype.slice.call(arguments);
		args.unshift('[warn]');
		args.unshift('\t');
		args.unshift(timestamp());
		console.log.apply(null, args);
	}

	/**
	 * Log method, log level error.
	 */
	_error() {
		if (!this.options.debug) return;
		const args = Array.prototype.slice.call(arguments);
		args.unshift('[error]');
		args.unshift('\t');
		args.unshift(timestamp());
		console.error.apply(null, args);
	}
}

/**
 * Create current timestamp,
 * HH:MM:SS:sss
 * @returns {string}
 */
function timestamp() {
	const d = new Date();
	return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}:${pad(d.getMilliseconds())}`;
}

/**
 * Pad a value with zero if necessary.
 * @param value
 * @returns {string}
 */
function pad(value) {
	return (value < 10) ? `0${value}` : value;
}

module.exports = DeviceDriver;
